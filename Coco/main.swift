
/*-------------------------------------------------------------------------
    Compiler Generator Coco/R,
    Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
    extended by M. Loeberbauer & A. Woess, Univ. of Linz
    with improvements by Pat Terry, Rhodes University
    Swift port by Michael Griebling, Computer Inspirations

    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2, or (at your option) any
    later version.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

    As an exception, it is allowed to write an extension of Coco/R that is
    used as a plugin in non-free software.

    If not otherwise stated, any source code generated by Coco/R (other than
    Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------
    Trace output options
    0 | A: prints the states of the scanner automaton
    1 | F: prints the First and Follow sets of all nonterminals
    2 | G: prints the syntax graph of the productions
    3 | I: traces the computation of the First sets
    4 | J: prints the sets associated with ANYs and synchronisation sets
    6 | S: prints the symbol table (terminals, nonterminals, pragmas)
    7 | X: prints a cross reference list of all syntax symbols
    8 | P: prints statistics about the Coco run

    Trace output can be switched on by the pragma
    $ { digit | letter }
    in the attributed grammar or as a command-line option
-------------------------------------------------------------------------*/

import Foundation

extension String {
	
	func Trim() -> String {
		return self.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceCharacterSet())
	}
	
}

public class Coco {
	
	public static func Main (arg: [String]) -> Int {
		print("Coco/R (Aug 19, 2015)")
		var srcName : NSString = ""
		var nsName = ""
		var frameDir = ""
		var ddtString = ""
		var traceFileName = ""
		var outDir = ""
		var emitLines = false
		var retVal = 1
		var i = 0
		while i < arg.count {
			if (arg[i] == "-namespace" && i < arg.count - 1) { nsName = arg[++i].Trim() }
			else if (arg[i] == "-frames" && i < arg.count - 1) { frameDir = arg[++i].Trim() }
			else if (arg[i] == "-trace" && i < arg.count - 1) { ddtString = arg[++i].Trim() }
			else if (arg[i] == "-o" && i < arg.count - 1) { outDir = arg[++i].Trim() }
			else if (arg[i] == "-lines") { emitLines = true }
			else { srcName = arg[i] }
			i++
		}
		
		if arg.count > 1 && srcName.length != 0 {
			do {
				let srcDir = srcName.stringByDeletingLastPathComponent
				
				let scanner = Scanner(fileName: String(srcName))
				let parser = Parser(scanner: scanner)
				
                traceFileName = (srcDir as NSString).stringByAppendingPathComponent("trace.txt")
                parser.trace = NSOutputStream(toFileAtPath: traceFileName, append: false)
                parser.tab = Tab(parser: parser)
                parser.dfa = DFA(parser: parser)
                parser.pgen = ParserGen(parser: parser)
                
                parser.tab.srcName = srcName as String;
                parser.tab.srcDir = srcDir;
                parser.tab.nsName = nsName;
                parser.tab.frameDir = frameDir;
                parser.tab.outDir = !outDir.isEmpty ? outDir : srcDir
                parser.tab.emitLines = emitLines
                if !ddtString.isEmpty { parser.tab.SetDDT(ddtString) }
                
                parser.Parse()
                
                parser.trace?.close()
                let fs = NSFileManager.defaultManager()
                let f = try fs.attributesOfFileSystemForPath(traceFileName)
                if f.count == 0 { try fs.removeItemAtPath(traceFileName) }
                else { print("trace output is in " + traceFileName) }
                print("\(parser.errors.count) errors detected")
                if parser.errors.count == 0 { retVal = 0 }
            } catch _ {
                print("-- could not open " + traceFileName)
//            } catch (FatalError e) {
//                print("-- " + e.Message)
			}
		} else {
			print("Usage: Coco Grammar.ATG {{Option}}\n"
				+ "Options:\n"
				+ "  -namespace <namespaceName>\n"
				+ "  -frames    <frameFilesDirectory>\n"
				+ "  -trace     <traceString>\n"
				+ "  -o         <outputDirectory>\n"
				+ "  -lines\n"
				+ "Valid characters in the trace string:\n"
				+ "  A  trace automaton\n"
				+ "  F  list first/follow sets\n"
				+ "  G  print syntax graph\n"
				+ "  I  trace computation of first sets\n"
				+ "  J  list ANY and SYNC sets\n"
				+ "  P  print statistics\n"
				+ "  S  list symbol table\n"
				+ "  X  list cross reference table\n"
				+ "Scanner.frame and Parser.frame files needed in ATG directory\n"
				+ "or in a directory specified in the -frames option.")
		}
        return retVal
	}
	
} // end Coco

Coco.Main(Process.arguments)

