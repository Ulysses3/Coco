/*-------------------------------------------------------------------------
Tab.cs -- Symbol Table Management
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University
Swift port by Michael Griebling, Computer Inspirations

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/

import Foundation

public struct Position {  // position of source code stretch (e.g. semantic action, resolver expressions)
	public let beg: Int      // start relative to the beginning of the file
	public let end: Int      // end of stretch
	public let col: Int      // column number of start position
	public let line: Int     // line number of start position
	
	public init(beg: Int, end: Int, col: Int, line: Int) {
		self.beg = beg; self.end = end; self.col = col; self.line = line
	}
}

//public typealias BitArray = [Bool]
public typealias CharSet = Set<Character>

//=====================================================================
// Symbol
//=====================================================================

public class Symbol {
	
	// token kinds
	public let fixedToken    = 0 // e.g. "a" ("b" | "c") (structure of literals)
	public let classToken    = 1 // e.g. digit {digit}   (at least one char class)
	public let litToken      = 2 // e.g. "while"
	public let classLitToken = 3 // e.g. letter {letter} but without literals that have the same structure
	
	public var n: Int            // symbol number
	public var typ: Int          // t, nt, pr, unknown, rslv /* ML 29_11_2002 slv added */ /* AW slv --> rslv */
	public var name: String      // symbol name
	public var graph: Node?      // nt: to first node of syntax graph
	public var tokenKind: Int    // t:  token kind (fixedToken, classToken, ...)
	public var deletable: Bool   // nt: true if nonterminal is deletable
	public var firstReady: Bool  // nt: true if terminal start symbols have already been computed
	public var first: BitArray   // nt: terminal start symbols
	public var follow: BitArray  // nt: terminal followers
	public var nts: BitArray     // nt: nonterminals whose followers have to be added to this sym
	public var line: Int         // source text line number of item in this node
	public var attrPos: Position? // nt: position of attributes in source text (or nil)
	public var semPos: Position  // pr: pos of semantic action in source text (or nil)
	// nt: pos of local declarations in source text (or nil)
	
	public init(typ: Int, name: String, line: Int) {
		self.typ = typ; self.name = name; self.line = line
	}
}

//=====================================================================
// Node
//=====================================================================

public class Node {
	// constants for node kinds
	public static let t    =  1  // terminal symbol
	public static let pr   =  2  // pragma
	public static let nt   =  3  // nonterminal symbol
	public static let clas =  4  // character class
	public static let chr  =  5  // character
	public static let wt   =  6  // weak terminal symbol
	public static let any  =  7  //
	public static let eps  =  8  // empty
	public static let sync =  9  // synchronization symbol
	public static let sem  = 10  // semantic action: (. .)
	public static let alt  = 11  // alternative: |
	public static let iter = 12  // iteration: { }
	public static let opt  = 13  // option: [ ]
	public static let rslv = 14  // resolver expr
	
	public static let normalTrans  = 0		// transition codes
	public static let contextTrans = 1
	
	public var n: Int			// node number
	public var typ: Int			// t, nt, wt, chr, clas, any, eps, sem, sync, alt, iter, opt, rslv
	public var next:Node?     		// to successor node
	public var down:Node?     		// alt: to next alternative
	public var sub:Node?		// alt, iter, opt: to first node of substructure
	public var up: Bool     			// true: "next" leads to successor in enclosing structure
	public var sym: Symbol?   		// nt, t, wt: symbol represented by this node
	public var val: Int      		// chr:  ordinal character value
	// clas: index of character class
	public var code: Int      		// chr, clas: transition code
	public var set: BitArray 		// any, sync: the set represented by this node
	public var pos: Position 		// nt, t, wt: pos of actual attributes
	// sem:       pos of semantic action in source text
	// rslv:       pos of resolver in source text
	public var line: Int      		// source text line number of item in this node
	public var state: State    	// DFA state corresponding to this node
	// (only used in DFA.ConvertToStates)
	
	public init(typ: Int, sym: Symbol?, line: Int) {
		self.typ = typ; self.sym = sym; self.line = line
	}
}

//=====================================================================
// Graph
//=====================================================================

public class Graph {
	public var l: Node?	// left end of graph = head
	public var r: Node?	// right end of graph = list of nodes to be linked to successor graph
	
	public init() {
		l = nil; r = nil
	}
	
	public init(left: Node?, right: Node?) {
		l = left; r = right
	}
	
	public init(p: Node?) {
		l = p; r = p
	}
}

//=====================================================================
// Sets
//=====================================================================

public class Sets {
	
	public static func Elements(s: BitArray) -> Int {
		var n = 0
		for item in s {
			if item { n++ }
		}
		return n
	}
	
	public static func Equals(a: BitArray, b: BitArray) -> Bool {
		return a.equals(b)
	}
	
	public static func Intersect(a: BitArray, b: BitArray) -> Bool { // a * b != {}
		let max = a.count
		for i in 0..<max {
			if a[i] && b[i] { return true }
		}
		return false
	}
	
	public static func Subtract(inout a: BitArray, b: BitArray) { // a = a - b
        a = a.and(b.not())
	}
	
}

public struct BitArray : CollectionType {
    
    var array: [Bool]
    
    // CollectionType protocol conformance
    public typealias Type = Int
    public var startIndex: Int { return 0 }
    public var endIndex: Int { return array.count }
    
	public init(size: Int, value: Bool = false) {
        array = [Bool](count: size, repeatedValue: value)
    }
    
    public var count: Int { return array.count }
    
    public subscript (index: Int) -> Bool {
        get { return array[index] }
        set { array[index] = newValue }
    }
    
    public func and (b: BitArray) -> BitArray {
        let max = array.count
        var result = BitArray(size: max)
        for i in 0..<max {
            result[i] = array[i] && b[i]
        }
        return result
    }
    
    public func or (b: BitArray) -> BitArray {
        let max = array.count
        var result = BitArray(size: max)
        for i in 0..<max {
            result[i] = array[i] || b[i]
        }
        return result
    }
    
    public func not () -> BitArray {
        let max = array.count
        var result = BitArray(size: max)
        for i in 0..<max {
            result[i] = !array[i]
        }
        return result
    }
    
    public func equals (b: BitArray) -> Bool {
        return array == b.array
    }
    
}

//=====================================================================
// CharClass
//=====================================================================

public class CharClass {
	public var n: Int       	// class number
	public var name: String		// class name
	public var set: CharSet		// set representing the class
	
	public init(name: String, s: CharSet) {
		self.name = name; self.set = s
	}
}

extension NSOutputStream {
	
	func Write (s: String) {
		let data: NSData = s.dataUsingEncoding(NSUTF8StringEncoding)!
		self.write(UnsafePointer(data.bytes), maxLength: data.length)
	}
	
	func WriteLine (s: String = "") { Write(s + "\n") }
	
}

//=====================================================================
// Tab
//=====================================================================

public class Tab {
	public var semDeclPos: Position       // position of global semantic declarations
	public var ignored:CharSet            // characters ignored by the scanner
	public var ddt = [Bool](count: 10, repeatedValue: false) // debug and test switches
	public var gramSy:Symbol              // root nonterminal: filled by ATG
	public var eofSy:Symbol               // end of file symbol
	public var noSym: Symbol              // used in case of an error
	public var allSyncSets:BitArray       // union of all synchronisation sets
	public var literals:[String: Symbol]  // symbols that are used as literals
	
	public var srcName:String             // name of the atg file (including path)
	public var srcDir:String              // directory path of the atg file
	public var nsName:String              // namespace for generated files
	public var frameDir:  String          // directory containing the frame files
	public var outDir:String              // directory for generated files
	public var checkEOF = true      // should coco generate a check for EOF at
	//   the end of Parser.Parse():
	public var emitLines:Bool             // emit #line pragmas for semantic actions
	//   in the generated parser
	
	var visited: BitArray                  // mark list for graph traversals
	var curSy: Symbol                      // current symbol in computation of sets
	
	var parser: Parser                     // other Coco objects
	var trace: NSOutputStream
	var errors: Errors
	
	public init(parser: Parser) {
		self.parser = parser
		trace = parser.trace
		errors = parser.errors
		eofSy = NewSym(Node.t, name: "EOF", line: 0)
		dummyNode = NewNode(Node.eps, sym: nil, line: 0)
		literals = [:]
	}
	
	//---------------------------------------------------------------------
	//  Symbol list management
	//---------------------------------------------------------------------
	
	public static var terminals = [Symbol]()
	public static var pragmas = [Symbol]()
	public static var nonterminals = [Symbol]()
	
	let tKind = ["fixedToken", "classToken", "litToken", "classLitToken"]
	
	public func NewSym(typ: Int, var name: String, line: Int) -> Symbol {
		if name.count() == 2 && name[0] == "\"" {
			parser.SemErr("empty token not allowed"); name = "???"
		}
		let sym = Symbol(typ: typ, name: name, line: line)
		switch typ {
		case Node.t:  sym.n = Tab.terminals.count; Tab.terminals.append(sym)
		case Node.pr: Tab.pragmas.append(sym)
		case Node.nt: sym.n = Tab.nonterminals.count; Tab.nonterminals.append(sym)
		}
		return sym
	}
	
	public func FindSym(name: String) -> Symbol? {
		for s in Tab.terminals {
			if s.name == name { return s }
		}
		for s in Tab.nonterminals {
			if s.name == name { return s }
		}
		return nil
	}
	
	func Num(p: Node?) -> Int {
		if let p = p { return p.n }
		else { return 0 }
	}
	
	func PrintSym(sym: Symbol) {
		trace.Write("\(sym.n) \(Name(sym.name)) \(Tab.nTyp[sym.typ])")
		if (sym.attrPos == nil) { trace.Write(" false ") } else { trace.Write(" true  ") }
		if (sym.typ == Node.nt) {
			trace.Write("\(Num(sym.graph))")
			if (sym.deletable) { trace.Write(" true  ") } else { trace.Write(" false ") }
		} else {
			trace.Write("            ")
		}
		trace.WriteLine("\(sym.line) \(tKind[sym.tokenKind)")
	}
	
	public func PrintSymbolTable() {
		trace.WriteLine("Symbol Table:")
		trace.WriteLine("------------"); trace.WriteLine()
		trace.WriteLine(" nr name          typ  hasAt graph  del    line tokenKind")
		for sym in Tab.terminals { PrintSym(sym) }
		for sym in Tab.pragmas { PrintSym(sym) }
		for sym in Tab.nonterminals { PrintSym(sym) }
		trace.WriteLine()
		trace.WriteLine("Literal Tokens:")
		trace.WriteLine("--------------")
		for e in literals {
			trace.WriteLine("_" + Symbol(e.Value).name + " = " + e.Key + ".")
		}
		trace.WriteLine()
	}
	
	public func PrintSet(s: BitArray, indent: Int) {
		var col = indent
		var len: Int
		for sym in Tab.terminals {
			if s[sym.n] {
				len = sym.name.count()
				if col + len >= 80 {
					trace.WriteLine();
					for _ in 1..<indent { trace.Write(" ") }
				}
				trace.Write(sym.name + " ")
				col += len + 1
			}
		}
		if col == indent { trace.Write("-- empty set --") }
		trace.WriteLine()
	}
	
	//---------------------------------------------------------------------
	//  Syntax graph management
	//---------------------------------------------------------------------
	
	public static var nodes = [Node]()
	public static let nTyp = ["    ", "t   ", "pr  ", "nt  ", "clas", "chr ", "wt  ", "any ", "eps ",
		"sync", "sem ", "alt ", "iter", "opt ", "rslv"]
	var dummyNode: Node
	
	public func NewNode(typ: Int, sym: Symbol?, line: Int) -> Node {
		let node = Node(typ: typ, sym: sym, line: line)
		node.n = Tab.nodes.count
		Tab.nodes.append(node)
		return node
	}
	
	public func NewNode(typ: Int, sub: Node) -> Node {
		let node = NewNode(typ, sym: nil, line: 0)
		node.sub = sub
		return node
	}
	
	public func NewNode(typ: Int, val: Int, line: Int) -> Node {
		let node = NewNode(typ, sym: nil, line: line)
		node.val = val
		return node
	}
	
	public func MakeFirstAlt(g: Graph) {
		g.l = NewNode(Node.alt, sub: g.l!); g.l!.line = g.l!.sub!.line
		g.r!.up = true
		g.l!.next = g.r
		g.r = g.l
	}
	
	// The result will be in g1
	public func MakeAlternative(g1: Graph, g2: Graph) {
		g2.l = NewNode(Node.alt, sub: g2.l!); g2.l!.line = g2.l!.sub!.line
		g2.l!.up = true
		g2.r!.up = true
		var p = g1.l; while p!.down != nil { p = p!.down }
		p!.down = g2.l
		p = g1.r; while p!.next != nil { p = p!.next }
		// append alternative to g1 end list
		p!.next = g2.l
		// append g2 end list to g1 end list
		g2.l!.next = g2.r
	}
	
	// The result will be in g1
	public func MakeSequence(g1: Graph, g2: Graph) {
		var p = g1.r!.next; g1.r!.next = g2.l // link head node
		while p != nil {  // link substructure
			let q = p!.next; p!.next = g2.l
			p = q
		}
		g1.r = g2.r
	}
	
	public func MakeIteration(g: Graph) {
		g.l = NewNode(Node.iter, sub: g.l!)
		g.r!.up = true
		var p = g.r
		g.r = g.l
		while p != nil {
			let q = p!.next; p!.next = g.l
			p = q
		}
	}
	
	public func MakeOption(g: Graph) {
		g.l = NewNode(Node.opt, sub: g.l!)
		g.r!.up = true
		g.l!.next = g.r
		g.r = g.l
	}
	
	public func Finish(g: Graph) {
		var p = g.r
		while p != nil {
			let q = p!.next; p!.next = nil
			p = q
		}
	}
	
	public func DeleteNodes() {
		Tab.nodes = [Node]()
		dummyNode = NewNode(Node.eps, sym: nil, line: 0)
	}
	
	public func StrToGraph(str: String) -> Graph {
		let ns : NSString = str
		let s = Unescape(ns.substringToIndex(str.count()-2))
		if s.count() == 0 { parser.SemErr("empty token not allowed") }
		let g = Graph()
		g.r = dummyNode
		for i in 0..<s.count() {
			let p = NewNode(Node.chr, val: s[i].unicodeValue(), line: 0)
			g.r!.next = p; g.r = p
		}
		g.l = dummyNode.next; dummyNode.next = nil
		return g
	}
	
	public func SetContextTrans(var p: Node?) { // set transition code in the graph rooted at p
		while p != nil {
			if let np = p {
				if (np.typ == Node.chr || np.typ == Node.clas) {
					np.code = Node.contextTrans
				} else if (np.typ == Node.opt || np.typ == Node.iter) {
					SetContextTrans(np.sub)
				} else if (np.typ == Node.alt) {
					SetContextTrans(np.sub); SetContextTrans(np.down)
				}
				if np.up { break }
				p = np.next
			}
		}
	}
	
	//------------ graph deletability check -----------------
	
	public func DelGraph(p: Node?) -> Bool {
		return p == nil || DelNode(p) && DelGraph(p!.next)
	}
	
	public func DelSubGraph(p: Node?) -> Bool {
		return p == nil || DelNode(p) && (p!.up || DelSubGraph(p!.next));
	}
	
	public func DelNode(p: Node?) -> Bool {
		guard let p = p else { return false }
		if (p.typ == Node.nt) { return p.sym!.deletable }
		else if (p.typ == Node.alt) { return DelSubGraph(p.sub) || p.down != nil && DelSubGraph(p.down) }
		else { return p.typ == Node.iter || p.typ == Node.opt || p.typ == Node.sem
			|| p.typ == Node.eps || p.typ == Node.rslv || p.typ == Node.sync }
	}
	
	//----------------- graph printing ----------------------
	
	func Ptr(p: Node?, up: Bool) -> String {
		let ptr = p == nil ? "0" : String(p!.n)
		return (up) ? "-" + ptr : ptr
	}
	
	func Pos(pos: Position?) -> String {
		if pos == nil { return "     " } else { return "\(pos!.beg)" }
	}
	
	public func Name(name: String) -> String {
		return name.stringByPaddingToLength(12, withString: " ", startingAtIndex: 0)
	}
	
	public func PrintNodes() {
		trace.WriteLine("Graph nodes:");
		trace.WriteLine("----------------------------------------------------");
		trace.WriteLine("   n type name          next  down   sub   pos  line");
		trace.WriteLine("                               val  code");
		trace.WriteLine("----------------------------------------------------");
		for p in Tab.nodes {
			trace.Write("\(p.n) \(Tab.nTyp[p.typ]) ")
			if p.sym != nil {
				trace.Write("\(Name(p.sym!.name)) ")
			} else if (p.typ == Node.clas) {
				let c = Tab.classes[p.val]
				trace.Write("\(Name(c.name)) ")
			} else { trace.Write("             ") }
			trace.Write("\(Ptr(p.next, up: p.up)) ")
			switch p.typ {
			case Node.t, Node.nt, Node.wt:
				trace.Write("             \(Pos(p.pos))")
			case Node.chr:
				trace.Write("\(p.val) \(p.code)       ")
			case Node.clas:
				trace.Write("      \(p.code)       ")
			case Node.alt, Node.iter, Node.opt:
				trace.Write("\(Ptr(p.down, up: false)) \(Ptr(p.sub, up: false))       ")
			case Node.sem:
				trace.Write("             \(Pos(p.pos))")
			case Node.eps, Node.any, Node.sync:
				trace.Write("                  ")
			}
			trace.WriteLine("\(p.line)")
		}
		trace.WriteLine()
	}
	
	
	//---------------------------------------------------------------------
	//  Character class management
	//---------------------------------------------------------------------
	
	public static var classes = [CharClass]()
	public static var dummyName : Character = "A"
	
	public func NewCharClass(var name: String, s: CharSet) -> CharClass {
		if name == "#" { name = "#" + String(Tab.dummyName); Tab.dummyName++ }
		let c = CharClass(name: name, s: s)
		c.n = Tab.classes.count
		Tab.classes.append(c)
		return c
	}
	
	public func FindCharClass(name: String) -> CharClass? {
		for c in Tab.classes {
			if c.name == name { return c }
		}
		return nil
	}
	
	public func FindCharClass(s: CharSet) -> CharClass? {
		for c in Tab.classes {
			if s == c.set { return c }
		}
		return nil
	}
	
	public func CharClassSet(i: Int) -> CharSet {
		return Tab.classes[i].set
	}
	
	//----------- character class printing
	
	func Ch(ch: Int) -> String {
		if (Character(ch) < " " || ch >= 127 || Character(ch) == "'" || Character(ch) == "\\") { return String(ch) }
		else { return "\(Character(ch))" }
	}
	
	func WriteCharSet(s: CharSet) {
		for (var r = s.head; r != nil; r = r!.next) {
			if (r!.from < r!.to) { trace.Write(Ch(r!.from) + ".." + Ch(r!.to) + " ") }
			else { trace.Write(Ch(r!.from) + " ") }
		}
	}
	
	public func WriteCharClasses () {
		for c in Tab.classes {
			trace.Write("\(c.name): ")
			WriteCharSet(c.set);
			trace.WriteLine();
		}
		trace.WriteLine();
	}
	
	
	//---------------------------------------------------------------------
	//  Symbol set computations
	//---------------------------------------------------------------------
	
	/* Computes the first set for the graph rooted at p */
	func First0(var p: Node?, var mark: BitArray) -> BitArray {
		var fs = BitArray(size: Tab.terminals.count)
		while p != nil && !mark[p!.n] {
			mark[p!.n] = true
			switch p!.typ {
			case Node.nt:
				if p!.sym!.firstReady { fs.or(p!.sym!.first) }
				else { fs.or(First0(p!.sym!.graph, mark: mark)) }
			case Node.t, Node.wt:
				fs[p!.sym!.n] = true
			case Node.any:
				fs.or(p!.set)
			case Node.alt:
				fs.or(First0(p!.sub, mark: mark))
				fs.or(First0(p!.down, mark: mark))
			case Node.iter, Node.opt:
				fs.or(First0(p!.sub, mark: mark))
			}
			if !DelNode(p) { break }
			p = p!.next
		}
		return fs
	}
	
    public func First(p: Node?) -> BitArray {
        let fs = First0(p, mark: BitArray(size: Tab.nodes.count))
        if (ddt[3]) {
            trace.WriteLine()
            if p != nil { trace.WriteLine("First: node = \(p!.n)") }
            else { trace.WriteLine("First: node = nil") }
            PrintSet(fs, indent: 0)
        }
        return fs
    }
	
	func CompFirstSets() {
		for sym in Tab.nonterminals {
            sym.first = BitArray(size:Tab.terminals.count)
			sym.firstReady = false
		}
		for sym in Tab.nonterminals {
			sym.first = First(sym.graph)
			sym.firstReady = true
		}
	}
	
    func CompFollow(var p: Node?) {
        while let np = p where !visited[np.n] {
            visited[np.n] = true
            if np.typ == Node.nt {
                let s = First(np.next)
                np.sym!.follow.or(s)
                if DelGraph(np.next) {
                    np.sym!.nts[curSy.n] = true
                }
            } else if np.typ == Node.opt || np.typ == Node.iter {
                CompFollow(np.sub)
            } else if np.typ == Node.alt {
                CompFollow(np.sub); CompFollow(np.down);
            }
            p = np.next
        }
    }
	
    func Complete(sym: Symbol) {
		if !visited[sym.n] {
			visited[sym.n] = true
			for s in Tab.nonterminals {
				if (sym.nts[s.n]) {
					Complete(s);
					sym.follow.or(s.follow)
                    if sym === curSy { sym.nts[s.n] = false }
				}
			}
		}
	}
	
	func CompFollowSets() {
		for sym in Tab.nonterminals {
			sym.follow = BitArray(size:Tab.terminals.count)
			sym.nts = BitArray(size:Tab.nonterminals.count)
		}
		gramSy.follow[eofSy.n] = true;
        visited = BitArray(size:Tab.nodes.count)
		for sym in Tab.nonterminals { // get direct successors of nonterminals
			curSy = sym;
			CompFollow(sym.graph)
		}
		for sym in Tab.nonterminals { // add indirect successors to followers
			visited = BitArray(size:Tab.nonterminals.count)
			curSy = sym
			Complete(sym)
		}
	}
	
    func LeadingAny(p: Node?) -> Node? {
        guard let p = p else { return nil }
        var a: Node? = nil
        if p.typ == Node.any { a = p }
        else if p.typ == Node.alt {
            a = LeadingAny(p.sub);
            if a == nil { a = LeadingAny(p.down) }
        }
        else if (p.typ == Node.opt || p.typ == Node.iter) { a = LeadingAny(p.sub) }
        if (a == nil && DelNode(p) && !p.up) { a = LeadingAny(p.next) }
        return a
    }
    
    func FindAS(var p: Node?) { // find ANY sets
        var a: Node?
        while let np = p {
            if np.typ == Node.opt || np.typ == Node.iter {
                FindAS(np.sub);
                a = LeadingAny(np.sub);
                if a != nil { Sets.Subtract(&a!.set, b:First(np.next)) }
            } else if np.typ == Node.alt {
                let s1 = BitArray(size: Tab.terminals.count)
                var q: Node? = np
                while let qp = q {
                    FindAS(qp.sub);
                    a = LeadingAny(qp.sub)
                    if a != nil {
                        Sets.Subtract(&a!.set, b:First(qp.down).or(s1))
                    } else {
                        s1.or(First(qp.sub))
                    }
                    q = qp.down
                }
            }
            
            // Remove alternative terminals before ANY, in the following
            // examples a and b must be removed from the ANY set:
            // [a] ANY, or {a|b} ANY, or [a][b] ANY, or (a|) ANY, or
            // A = [a]. A ANY
            if (DelNode(p)) {
                a = LeadingAny(np.next);
                if (a != nil) {
                    let q = (np.typ == Node.nt) ? np.sym!.graph : np.sub
                    Sets.Subtract(&a!.set, b:First(q))
                }
            }
            
            if np.up { break }
            p = np.next
        }
    }
	
	func CompAnySets() {
        for sym in Tab.nonterminals { FindAS(sym.graph) }
	}
	
    public func Expected(p: Node, curSy: Symbol) -> BitArray {
        let s = First(p)
        if DelGraph(p) { s.or(curSy.follow) }
        return s
    }
    
    // does not look behind resolvers; only called during LL(1) test and in CheckRes
    public func Expected0 (p: Node, curSy: Symbol) -> BitArray {
        if p.typ == Node.rslv { return BitArray(size:Tab.terminals.count) }
        else { return Expected(p, curSy: curSy) }
    }
	
	func CompSync(var p: Node?) {
		while let pn = p where !visited[pn.n] {
			visited[pn.n] = true
			if (pn.typ == Node.sync) {
				var s = Expected(pn.next!, curSy: curSy)
				s[eofSy.n] = true
				allSyncSets.or(s)
				pn.set = s
			} else if pn.typ == Node.alt {
				CompSync(pn.sub); CompSync(pn.down)
			} else if pn.typ == Node.opt || pn.typ == Node.iter {
				CompSync(pn.sub)
			}
			p = pn.next
		}
	}
	
	func CompSyncSets() {
		allSyncSets = BitArray(size: Tab.terminals.count)
		allSyncSets[eofSy.n] = true
		visited = BitArray(size: Tab.nodes.count)
		for sym in Tab.nonterminals {
			curSy = sym
			CompSync(curSy.graph)
		}
	}
	
	public func SetupAnys() {
		for p in Tab.nodes {
			if p.typ == Node.any {
				p.set = BitArray(size: Tab.terminals.count, value:true)
				p.set[eofSy.n] = false
			}
		}
	}
	
	public func CompDeletableSymbols() {
		var changed: Bool
		repeat {
			changed = false
			for sym in Tab.nonterminals {
				if !sym.deletable && sym.graph != nil && DelGraph(sym.graph) {
					sym.deletable = true; changed = true
				}
			}
		} while changed
		for sym in Tab.nonterminals {
			if sym.deletable { errors.Warning("  " + sym.name + " deletable") }
		}
	}
	
	public func RenumberPragmas() {
		var n = Tab.terminals.count
		for sym in Tab.pragmas { sym.n = n++ }
	}
	
	public func CompSymbolSets() {
		CompDeletableSymbols();
		CompFirstSets();
		CompAnySets();
		CompFollowSets();
		CompSyncSets();
		if ddt[1] {
			trace.WriteLine();
			trace.WriteLine("First & follow symbols:");
			trace.WriteLine("----------------------"); trace.WriteLine();
			for sym in Tab.nonterminals {
				trace.WriteLine(sym.name)
				trace.Write("first:   "); PrintSet(sym.first, indent: 10);
				trace.Write("follow:  "); PrintSet(sym.follow, indent: 10);
				trace.WriteLine()
			}
		}
		if ddt[4] {
			trace.WriteLine();
			trace.WriteLine("ANY and SYNC sets:");
			trace.WriteLine("-----------------");
			for p in Tab.nodes {
				if p.typ == Node.any || p.typ == Node.sync {
					trace.Write("\(p.n) \(Tab.nTyp[p.typ]): ")
					PrintSet(p.set, indent: 11)
				}
			}
		}
	}
	
	//---------------------------------------------------------------------
	//  String handling
	//---------------------------------------------------------------------
	
	func Hex2Char(s: String) -> Character {
		var val = 0
		for i in 0..<s.count() {
			let ch = s[i]
			if "0" <= ch && ch <= "9" { val = 16 * val + (ch - Character("0")) }
			else if "a" <= ch && ch <= "f" { val = 16 * val + (10 + (ch - Character("a"))) }
			else if "A" <= ch && ch <= "F" { val = 16 * val + (10 + (ch - Character("A"))) }
			else { parser.SemErr("bad escape sequence in string or character") }
		}
		if val > Int(UniChar.max) { /* pdt */
			parser.SemErr("bad escape sequence in string or character")
		}
		return Character(val)
	}
	
	func Char2Hex(ch: Character) -> String {
		let s = String(format: "\\u%04x", ch.unicodeValue())
		return s
	}
	
	public func Unescape (s: String) -> String {
		/* replaces escape sequences in s by their Unicode values. */
		var buf = ""
		var i = 0
		while i < s.count() {
			if s[i] == "\\" {
				switch s[i+1] {
				case "\\": buf += "\\"; i += 2
				case "'":  buf += "'"; i += 2
				case "\"": buf += "\""; i += 2
				case "r": buf += "\r"; i += 2
				case "n": buf += "\n"; i += 2
				case "t": buf += "\t"; i += 2
				case "0": buf += "\0"; i += 2
				case "a": buf += "\u{07}"; i += 2
				case "b": buf += "\u{08}"; i += 2
				case "f": buf += "\u{0c}"; i += 2
				case "v": buf += "\u{0b}"; i += 2
				case "u", "x":
					if i+6 <= s.count() {
						let sn : NSString = s
						buf.append(Hex2Char(sn.substringWithRange(NSMakeRange(i+2, 4)))); i += 6
					} else {
						parser.SemErr("bad escape sequence in string or character"); i = s.count()
					}
				default: parser.SemErr("bad escape sequence in string or character"); i += 2
				}
			} else {
				buf.append(s[i])
				i++
			}
		}
		return buf
	}
	
	public func Escape (s: String) -> String {
		var buf = ""
		for ch in s.characters {
			switch(ch) {
			case "\\": buf += "\\\\"
			case "'": buf += "\\'"
			case "\"": buf += "\\\""
			case "\t": buf += "\\t"
			case "\r": buf += "\\r"
			case "\n": buf += "\\n"
			default:
				if ch < " " || ch > "\u{7f}" { buf += Char2Hex(ch) }
				else { buf.append(ch) }
			}
		}
		return buf
	}

	//---------------------------------------------------------------------
	//  Grammar checks
	//---------------------------------------------------------------------
	
	public func GrammarOk() -> Bool {
		let ok = NtsComplete() && AllNtReached() && NoCircularProductions() && AllNtToTerm()
		if ok { CheckResolvers(); CheckLL1() }
		return ok
	}

	//--------------- check for circular productions ----------------------
	
	class CNode {	// node of list for finding circular productions
		var left: Symbol?
		var right: Symbol?
		
		init (l: Symbol?, r: Symbol?) {
			left = l; right = r
		}
	}

	func GetSingles(p: Node?, inout singles: [Symbol]) {
		guard let np = p else { return }  // end of graph
		if np.typ == Node.nt {
			if np.up || DelGraph(np.next) { singles.append(np.sym!) }
		} else if np.typ == Node.alt || np.typ == Node.iter || np.typ == Node.opt {
			if np.up || DelGraph(np.next) {
				GetSingles(np.sub, singles: &singles)
				if np.typ == Node.alt { GetSingles(np.down, singles: &singles) }
			}
		}
		if !np.up && DelNode(np) { GetSingles(np.next, singles: &singles) }
	}
	
	public func NoCircularProductions() -> Bool {
		var list = [CNode]()
		for sym in Tab.nonterminals {
			var singles = [Symbol]()
			GetSingles(sym.graph, singles: &singles) // get nonterminals s such that sym-->s
			for s in singles { list.append(CNode(l: sym, r: s)) }
		}
		var onLeftSide: Bool
		var onRightSide: Bool
		var changed: Bool
		repeat {
			changed = false
			for var i=0; i<list.count; i++ {
				var n = list[i]
				onLeftSide = false; onRightSide = false
				for m in list {
					if n.left === m.right { onRightSide = true }
					if n.right === m.left { onLeftSide = true }
				}
				if !onLeftSide || !onRightSide {
					list.Remove(n); i--; changed = true
				}
			}
		} while changed
		var ok = true
		for n in list {
			ok = false
			errors.SemErr("  " + n.left.name + " --> " + n.right.name);
		}
		return ok
	}

	//--------------- check for LL(1) errors ----------------------
	
	func LL1Error(int cond, Symbol sym) {
		String s = "  LL1 warning in " + curSy.name + ": ";
		if (sym != nil) s += sym.name + " is ";
		switch (cond) {
		case 1: s += "start of several alternatives"; break;
		case 2: s += "start & successor of deletable structure"; break;
		case 3: s += "an ANY node that matches no symbol"; break;
		case 4: s += "contents of [...] or {...} must not be deletable"; break;
		}
		errors.Warning(s);
	}
	
	func CheckOverlap(BitArray s1, BitArray s2, int cond) {
		foreach (Symbol sym in terminals) {
			if (s1[sym.n] && s2[sym.n]) LL1Error(cond, sym);
		}
	}

func CheckAlts(Node p) {
	BitArray s1, s2;
	while (p != nil) {
		if (p.typ == Node.alt) {
			Node q = p;
			s1 = new BitArray(terminals.Count);
			while (q != nil) { // for all alternatives
				s2 = Expected0(q.sub, curSy);
				CheckOverlap(s1, s2, 1);
				s1.Or(s2);
				CheckAlts(q.sub);
				q = q.down;
			}
		} else if (p.typ == Node.opt || p.typ == Node.iter) {
			if (DelSubGraph(p.sub)) LL1Error(4, nil); // e.g. [[...]]
			else {
				s1 = Expected0(p.sub, curSy);
				s2 = Expected(p.next, curSy);
				CheckOverlap(s1, s2, 2);
			}
			CheckAlts(p.sub);
		} else if (p.typ == Node.any) {
			if (Sets.Elements(p.set) == 0) LL1Error(3, nil);
			// e.g. {ANY} ANY or [ANY] ANY or ( ANY | ANY )
		}
		if (p.up) break;
		p = p.next;
	}
}

public func CheckLL1() {
	foreach (Symbol sym in nonterminals) {
		curSy = sym;
		CheckAlts(curSy.graph);
	}
}

//------------- check if resolvers are legal  --------------------

func ResErr(Node p, String msg) {
	errors.Warning(p.line, p.pos.col, msg);
}

func CheckRes(Node p, bool rslvAllowed) {
	while (p != nil) {
		switch (p.typ) {
		case Node.alt:
			BitArray expected = new BitArray(terminals.Count);
			for (Node q = p; q != nil; q = q.down)
			expected.Or(Expected0(q.sub, curSy));
			BitArray soFar = new BitArray(terminals.Count);
			for (Node q = p; q != nil; q = q.down) {
				if (q.sub.typ == Node.rslv) {
					BitArray fs = Expected(q.sub.next, curSy);
					if (Sets.Intersect(fs, soFar))
					ResErr(q.sub, "Warning: Resolver will never be evaluated. " +
					"Place it at previous conflicting alternative.");
					if (!Sets.Intersect(fs, expected))
					ResErr(q.sub, "Warning: Misplaced resolver: no LL(1) conflict.");
				} else soFar.Or(Expected(q.sub, curSy));
				CheckRes(q.sub, true);
			}
			break;
		case Node.iter: case Node.opt:
			if (p.sub.typ == Node.rslv) {
				BitArray fs = First(p.sub.next);
				BitArray fsNext = Expected(p.next, curSy);
				if (!Sets.Intersect(fs, fsNext))
				ResErr(p.sub, "Warning: Misplaced resolver: no LL(1) conflict.");
			}
			CheckRes(p.sub, true);
			break;
		case Node.rslv:
			if (!rslvAllowed)
			ResErr(p, "Warning: Misplaced resolver: no alternative.");
			break;
		}
		if (p.up) break;
		p = p.next;
		rslvAllowed = false;
	}
}

public func CheckResolvers() {
	foreach (Symbol sym in nonterminals) {
		curSy = sym;
		CheckRes(curSy.graph, false);
	}
}

//------------- check if every nts has a production --------------------

public bool NtsComplete() {
	bool complete = true;
	foreach (Symbol sym in nonterminals) {
		if (sym.graph == nil) {
			complete = false;
			errors.SemErr("  No production for " + sym.name);
		}
	}
	return complete;
}

//-------------- check if every nts can be reached  -----------------

func MarkReachedNts(Node p) {
	while (p != nil) {
		if (p.typ == Node.nt && !visited[p.sym.n]) { // new nt reached
			visited[p.sym.n] = true;
			MarkReachedNts(p.sym.graph);
		} else if (p.typ == Node.alt || p.typ == Node.iter || p.typ == Node.opt) {
			MarkReachedNts(p.sub);
			if (p.typ == Node.alt) MarkReachedNts(p.down);
		}
		if (p.up) break;
		p = p.next;
	}
}

public bool AllNtReached() {
	bool ok = true;
	visited = new BitArray(nonterminals.Count);
	visited[gramSy.n] = true;
	MarkReachedNts(gramSy.graph);
	foreach (Symbol sym in nonterminals) {
		if (!visited[sym.n]) {
			ok = false;
			errors.Warning("  " + sym.name + " cannot be reached");
		}
	}
	return ok;
}

//--------- check if every nts can be derived to terminals  ------------

bool IsTerm(Node p, BitArray mark) { // true if graph can be derived to terminals
	while (p != nil) {
		if (p.typ == Node.nt && !mark[p.sym.n]) return false;
		if (p.typ == Node.alt && !IsTerm(p.sub, mark)
		&& (p.down == nil || !IsTerm(p.down, mark))) return false;
		if (p.up) break;
		p = p.next;
	}
	return true;
}

public bool AllNtToTerm() {
	bool changed, ok = true;
	BitArray mark = new BitArray(nonterminals.Count);
	// a nonterminal is marked if it can be derived to terminal symbols
	do {
		changed = false;
		foreach (Symbol sym in nonterminals)
		if (!mark[sym.n] && IsTerm(sym.graph, mark)) {
			mark[sym.n] = true; changed = true;
		}
	} while (changed);
	foreach (Symbol sym in nonterminals)
	if (!mark[sym.n]) {
		ok = false;
		errors.SemErr("  " + sym.name + " cannot be derived to terminals");
	}
	return ok;
}

//---------------------------------------------------------------------
//  Cross reference list
//---------------------------------------------------------------------

public func XRef() {
	SortedList xref = new SortedList(new SymbolComp());
	// collect lines where symbols have been defined
	foreach (Symbol sym in nonterminals) {
		ArrayList list = (ArrayList)xref[sym];
		if (list == nil) {list = new ArrayList(); xref[sym] = list;}
		list.Add(- sym.line);
	}
	// collect lines where symbols have been referenced
	foreach (Node n in nodes) {
		if (n.typ == Node.t || n.typ == Node.wt || n.typ == Node.nt) {
			ArrayList list = (ArrayList)xref[n.sym];
			if (list == nil) {list = new ArrayList(); xref[n.sym] = list;}
			list.Add(n.line);
		}
	}
	// print cross reference list
	trace.WriteLine();
	trace.WriteLine("Cross reference list:");
	trace.WriteLine("--------------------"); trace.WriteLine();
	foreach (Symbol sym in xref.Keys) {
		trace.Write("  {0,-12}", Name(sym.name));
		ArrayList list = (ArrayList)xref[sym];
		int col = 14;
		foreach (int line in list) {
			if (col + 5 > 80) {
				trace.WriteLine();
				for (col = 1; col <= 14; col++) trace.Write(" ");
			}
			trace.Write("{0,5}", line); col += 5;
		}
		trace.WriteLine();
	}
	trace.WriteLine(); trace.WriteLine();
}

public func SetDDT(String s) {
	s = s.ToUpper();
	foreach (char ch in s) {
		if ("0" <= ch && ch <= "9") ddt[ch - "0"] = true;
		else switch (ch) {
		case "A" : ddt[0] = true; break; // trace automaton
		case "F" : ddt[1] = true; break; // list first/follow sets
		case "G" : ddt[2] = true; break; // print syntax graph
		case "I" : ddt[3] = true; break; // trace computation of first sets
		case "J" : ddt[4] = true; break; // print ANY and SYNC sets
		case "P" : ddt[8] = true; break; // print statistics
		case "S" : ddt[6] = true; break; // list symbol table
		case "X" : ddt[7] = true; break; // list cross reference table
		default : break;
		}
	}
}

public func SetOption(String s) {
	String[] option = s.Split(new char[] {"="}, 2);
	String name = option[0], value = option[1];
	if ("$namespace".Equals(name)) {
		if (nsName == nil) nsName = value;
	} else if ("$checkEOF".Equals(name)) {
		checkEOF = "true".Equals(value);
	}
}

class SymbolComp : IComparer {
	public int Compare(Object x, Object y)  {
	return ((Symbol) x).name.CompareTo(((Symbol) y).name);
	}
}

} // end Tab


